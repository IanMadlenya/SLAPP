--- ModelSwarm.py	(original)
+++ ModelSwarm.py	(refactored)
@@ -63,25 +63,25 @@
 
         # check consistency between types and classes
         if len(self.types) != len(self.classes):
-            print 'Mismatch in number of types and classes.'
+            print('Mismatch in number of types and classes.')
             os.sys.exit(1)
         for i in range(len(self.types)):
-            if not self.classes.has_key(self.types[i]):
-                print 'Type', self.types[i], 'has no class.'
+            if self.types[i] not in self.classes:
+                print('Type', self.types[i], 'has no class.')
                 os.sys.exit(1)
 
-        print '\nAgents and their classes'
+        print('\nAgents and their classes')
         for i in range(len(self.classes)):
-            print 'agents', self.types[i],'have class',\
-                  self.classes[self.types[i]]
-        print "'bland' agents, if any, have always class Agent\n"
+            print('agents', self.types[i],'have class',\
+                  self.classes[self.types[i]])
+        print("'bland' agents, if any, have always class Agent\n")
 
         # operating sets of the agents
         try:
             agOperatingSetFile=open(project+"/agOperatingSets.txt","r")
             self.operatingSets=agOperatingSetFile.read().split()
         except:
-            print 'Warning: operating sets not found.'
+            print('Warning: operating sets not found.')
             agOperatingSetFile = False
             self.operatingSets=[]
         if agOperatingSetFile: agOperatingSetFile.close()
@@ -90,7 +90,7 @@
 
         dictExe={}
         dictExe["project"]=project
-        execfile("./$$slapp$$/convert_xls_txt.py",dictExe)
+        exec(compile(open("./$$slapp$$/convert_xls_txt.py").read(), "./$$slapp$$/convert_xls_txt.py", 'exec'),dictExe)
 
     # objects
     def buildObjects(self):
@@ -115,7 +115,7 @@
                     random.randint(bottomY,topY), leftX,rightX,
                     bottomY,topY,agType="bland")
             self.agentList.append(anAgent)
-        print
+        print()
 
         # external agents, RELATED TO THE SPECIFIC project
         files=os.listdir(project)
@@ -126,19 +126,19 @@
              dictExe={}
              dictExe["project"]=project
              dictExe["fileName"]=agType
-             execfile("./$$slapp$$/convert_txtx_txt.py",dictExe)
+             exec(compile(open("./$$slapp$$/convert_txtx_txt.py").read(), "./$$slapp$$/convert_txtx_txt.py", 'exec'),dictExe)
 
         # update for new .txt file created above
         files=os.listdir(project)
 
         for agType in self.types:
-            if not agType+".txt" in files: print "No", agType,\
-               "agents: lacking the specific file", agType+".txt"
+            if not agType+".txt" in files: print("No", agType,\
+               "agents: lacking the specific file", agType+".txt")
 
         for opSet in self.operatingSets:
-            if not opSet+".txt" in files: print "No", opSet,\
-               "agents: lacking the specific file", opSet+".txt"
-        print
+            if not opSet+".txt" in files: print("No", opSet,\
+               "agents: lacking the specific file", opSet+".txt")
+        print()
 
         # crating the agents
         for agType in self.types:
@@ -149,7 +149,7 @@
             if line.split() != []:
                num=int(line.split()[0])
                if self.verbose and not common.IPython:
-                    print "creating "+agType+": agent #", num
+                    print("creating "+agType+": agent #", num)
                     # this output locks IPython when we have large number
                     # of agents
                #print line.split()
@@ -178,8 +178,8 @@
                 for anAgent in self.agentList:
                     if anAgent.number == num:
                         anAgent.setAnOperatingSet(opSet)
-                        print "including agent #", num, \
-                              "into the operating set", opSet
+                        print("including agent #", num, \
+                              "into the operating set", opSet)
            f.close()
 
         if self.operatingSets != []:
@@ -191,7 +191,7 @@
             anAgent.setAgentList(self.agentList)
 
 
-        print
+        print()
 
 
     # actions
@@ -297,7 +297,7 @@
                         if task[0] in ag.getOperatingSetList():
                             localList.append(ag)
                     if localList==[]:
-                        print "Warning, no agents in operating set", task[0]
+                        print("Warning, no agents in operating set", task[0])
                     # never in the same order (please comment if you want to keep
                     # always the same sequence
                     random.shuffle(localList)
@@ -332,7 +332,7 @@
                 if task[0]=='WorldState':
                     #self.share=0
                     if address.worldState==0:
-                        print "WorldState.py is missing, you cannot use WorldState here."
+                        print("WorldState.py is missing, you cannot use WorldState here.")
                         os.sys.exit(1)
                     localList=[address.worldState] #apply from schedule works on a list
                     self.applyFromSchedule(localList,task)
@@ -379,7 +379,7 @@
                                   if  float(lineSplit[1]) > 0:
                                     common.methodProbs[lineSplit[2]]=float(lineSplit[1])
                              if common.methodProbs != {}:
-                                 print "methodProbabilities =", common.methodProbs
+                                 print("methodProbabilities =", common.methodProbs)
                              schedule.close()
                            except: pass
 
@@ -394,7 +394,7 @@
                 if not found:
                  found=otherSubSteps(subStep, self)
 
-                if not found: print "Warning: step %s not found in Model" % subStep
+                if not found: print("Warning: step %s not found in Model" % subStep)
 
 
 
@@ -409,30 +409,30 @@
             #localList contains a unique worldState instance
             if task[1]=="computationalUse" or task[1]=="specialUse":
                 #localList contains a unique worldState instance
-                if common.debug: exec "localList[0]."+task[2]+"()"
+                if common.debug: exec("localList[0]."+task[2]+"()")
                 else:
-                  try: exec "localList[0]."+task[2]+"()"
-                  except: print task[2], "undefined in WorldState"
+                  try: exec("localList[0]."+task[2]+"()")
+                  except: print(task[2], "undefined in WorldState")
 
             # using WorldState to set/get values
 
             else:
                 try:  aValue = float(task[1]) # does task[1] contains a number?                                             # a number?
                 except:
-                    print "After WorldState, in schedule.xls we wait: "+\
+                    print("After WorldState, in schedule.xls we wait: "+\
                           "'computationalUse' or 'specialUse' or "+\
-                          "a number.", task[1],"found."
+                          "a number.", task[1],"found.")
                     os.sys.exit(1)
                 if task[2] != "":
                     d={}
                     d[task[2]]=float(task[1])
                     #localList contains a unique worldState instance
-                    if common.debug: exec "localList[0]."+task[2]+"(**d)"
+                    if common.debug: exec("localList[0]."+task[2]+"(**d)")
                     else:
-                      try: exec "localList[0]."+task[2]+"(**d)"
-                      except: print task[2], "undefined in WorldState"
+                      try: exec("localList[0]."+task[2]+"(**d)")
+                      except: print(task[2], "undefined in WorldState")
                 else:
-                    print "Unable to handle a missing task in WorldState schedule."
+                    print("Unable to handle a missing task in WorldState schedule.")
                     os.sys.exit(1)
 
         #if task[0] is 'all' or a type of agent
@@ -443,35 +443,35 @@
                # still operating for old calls in mActions.py modules nut it is
                # deprecated here, confusing the execution in presence of
                # subclasses of Agent
-               if common.debug: exec "askEachAgentInCollection(localList,task[2])"
+               if common.debug: exec("askEachAgentInCollection(localList,task[2])")
                else:
-                try: exec "askEachAgentInCollection(localList,task[2])"
+                try: exec("askEachAgentInCollection(localList,task[2])")
                 except:
-                    print "Warning, method", task[2],"does not exist"
+                    print("Warning, method", task[2],"does not exist")
             else:
                # see NOTE *** above
-               if common.debug: exec "askEachAgentInCollection(localList,task[1])"
+               if common.debug: exec("askEachAgentInCollection(localList,task[1])")
                else:
-                try: exec "askEachAgentInCollection(localList,task[1])"
+                try: exec("askEachAgentInCollection(localList,task[1])")
                 except:
-                    print "Warning, method", task[1],"does not exist"
+                    print("Warning, method", task[1],"does not exist")
 
         #if task[0] is an opSet
         if task[0] in self.operatingSets:
             if self.share!=0:
                # see NOTE *** above
-               if common.debug: exec "askEachAgentInCollection(localList,task[2])"
+               if common.debug: exec("askEachAgentInCollection(localList,task[2])")
                else:
-                try: exec "askEachAgentInCollection(localList,task[2])"
+                try: exec("askEachAgentInCollection(localList,task[2])")
                 except:
-                    print "Warning, method", task[2],"does not exist"
+                    print("Warning, method", task[2],"does not exist")
             else:
                # see NOTE *** above
-               if common.debug: exec "askEachAgentInCollection(localList,task[1])"
+               if common.debug: exec("askEachAgentInCollection(localList,task[1])")
                else:
-                try: exec "askEachAgentInCollection(localList,task[1])"
+                try: exec("askEachAgentInCollection(localList,task[1])")
                 except:
-                    print "Warning, method", task[1],"does not exist"
+                    print("Warning, method", task[1],"does not exist")
 
 
 
@@ -507,14 +507,14 @@
     # agent name, to eliminate a task due to the action made by
     # an agent)
     if not found and not s in opSets and s != '#' and not s.find("WorldState")==0:
-        print "agent", s, 'does not exist'
+        print("agent", s, 'does not exist')
 
     return found
 
 
 ## look for tasks to be added
 def addedTask(t):
-    if common.addTasks.has_key(t):
+    if t in common.addTasks:
        if common.addTasks[t] == []: return False
        else:                        return True
     else:                           return False
@@ -527,7 +527,7 @@
 
 ## look for tasks to be eliminated
 def elimTask(t):
-    if common.elimTasks.has_key(t):
+    if t in common.elimTasks:
        if common.elimTasks[t] == []: return False
        else:                         return True
     else:                            return False
@@ -546,7 +546,7 @@
 
     if found:
         common.elimTasks[t].pop(i)
-        print task[0],'modified to dummy in:', task
+        print(task[0],'modified to dummy in:', task)
         task[0]='dummy'
 
     return task
