--- graphicDisplayGlobalVarAndFunctions.py	(original)
+++ graphicDisplayGlobalVarAndFunctions.py	(refactored)
@@ -51,7 +51,7 @@
 def createEdge(a, b):
     # implicitly directed, due to the use of DiGraph
     if a == None or b == None:
-       print "Internal error, attempt to create an edge with a node defined None"
+       print("Internal error, attempt to create an edge with a node defined None")
        exit(0)
 
     try:
@@ -98,17 +98,17 @@
     if not common.prune: return
     common.prune=False
 
-    print "New threshold to prune: < %d" % common.pruneThreshold
+    print("New threshold to prune: < %d" % common.pruneThreshold)
 
     edges=common.g.edges()
-    print "weights of the links"
+    print("weights of the links")
     for anEdge in edges:
         u = anEdge[0].number
         uu= anEdge[0]
         v = anEdge[1].number
         vv= anEdge[1]
         w = common.g[anEdge[0]][anEdge[1]]["weight"]
-        print u, v, w
+        print(u, v, w)
 
         if w < common.pruneThreshold:
             # managing labels, related to createEdge phase above
@@ -135,7 +135,7 @@
     clearNetworkXdisplay()
     pruneEdges()
     nx.draw_networkx(common.g,pos,font_size=10,node_size=500, \
-         node_color=colors.values(), \
+         node_color=list(colors.values()), \
          labels = common.g_labels)
     nx.draw_networkx_edge_labels(common.g,pos,edge_labels=common.g_edge_labels,\
                                  font_size=9)
@@ -157,47 +157,47 @@
 
 
     # adjacency
-    print
+    print()
     for i in range(len(common.orderedListOfNodes)):
-      print "%d " % common.orderedListOfNodes[i].number,
-    print
+      print("%d " % common.orderedListOfNodes[i].number, end=' ')
+    print()
     #print "drawGraph verification of existing nodes",common.g.nodes()
     if common.g.nodes() !=[]:
         A = nx.adjacency_matrix(common.g, nodelist=common.orderedListOfNodes, \
                               weight='weight')
         #print A          # as sparse matrix, defaul from nx 1.9.1
-        print A.todense() # as a regular matrix
-
-    else: print "No nodes, impossible to create the adjacency_matrix"
-    print
+        print(A.todense()) # as a regular matrix
+
+    else: print("No nodes, impossible to create the adjacency_matrix")
+    print()
 
     # neighbors
 
     for aNode in common.g.nodes():
-        print aNode.number, [node.number \
-                                   for node in nx.neighbors(common.g,aNode)]
+        print(aNode.number, [node.number \
+                                   for node in nx.neighbors(common.g,aNode)])
 
     # betweenness_centrality
     # Betweenness centrality of a node v is the sum of the fraction of all-pairs
     # shortest paths that pass through v
     # http://networkx.lanl.gov/reference/generated/
     # networkx.algorithms.centrality.betweenness_centrality.html
-    print
-    print "betweenness_centrality"
+    print()
+    print("betweenness_centrality")
     common.btwn = nx.betweenness_centrality(common.g, normalized=False, weight='weight')
     #print btw
     for i in range(len(common.orderedListOfNodes)):
-        print common.orderedListOfNodes[i].number, \
-              common.btwn[common.orderedListOfNodes[i]]
+        print(common.orderedListOfNodes[i].number, \
+              common.btwn[common.orderedListOfNodes[i]])
 
     # closeness_centrality
     # Closeness centrality at a node is 1/average distance to all other nodes
     # http://networkx.lanl.gov/reference/generated/
     # networkx.algorithms.centrality.closeness_centrality.html
-    print
-    print "closeness_centrality"
+    print()
+    print("closeness_centrality")
     common.clsn = nx.closeness_centrality(common.g, normalized=False)
     #print clsn
     for i in range(len(common.orderedListOfNodes)):
-        print common.orderedListOfNodes[i].number, \
-              common.clsn[common.orderedListOfNodes[i]]
+        print(common.orderedListOfNodes[i].number, \
+              common.clsn[common.orderedListOfNodes[i]])
